# 如何加锁


### 普通的查询是基于快照读 MVCC （多版本并发控制） 是不加锁的

### 加锁的对象是索引
### 加锁的对象是索引
### 加锁的对象是索引

### 加锁的对象是针对索引，因为这里查询语句扫描的 B+ 树是聚簇索引树，即主键索引树，所以是对主键索引加锁。

> 如果是用二级索引，除了会对二级索引项加行级锁，还会对查询到的记录的主键索引项上加「记录锁」。


### 不可重复读 - 基于MVCC 就没搞定事务内重复读取不一致的问题（因为不可重复读每次读都会重新生成Read View）

### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁
### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁
### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁
### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁
### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁
### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁
### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁
### 幻读 - 开启事务后生成的Read View用于全局，但是还是顶不住有时候update这种当前读（不是快照读）的情况，会读到其他的事务更改的数据 （普通select一下，然后update所有，再select一下就不一样了），除非select全部是直接上锁

###  next-key lock 退化为记录锁 或者 间隙锁，或者不退化

### 加锁的基本单位是 next-key lock (记录锁和间隙锁组合) 前开后闭

> 以下针对MySQL 8.0.26

### next key lock 临键锁 (pre_line_number,next_key_number] (相当于锁住更改行到上一行记录范围但不包括上一行)

### 记录锁 [line_number] 相当于仅锁住一条记录

### 间隙锁 (pre_line_number,next_key_number) (相当于锁住了两个实际存在记录之间但不包括上一行和下一行)

### 不同的查找
```
唯一索引等值查询
唯一索引范围查询
非唯一索引等值查询
非唯一索引范围查询
```

### 已经存在的记录
```
id : { 0 , 4 , 8 , 16 , 32 }
b  : { 0 , 4 , 8 , 16 , 32 }
```

### 1.唯一索引等值查询和范围查询

> 唯一索引值存在时，记录锁
> 不存在时，间隙锁

```
where id=16 临键锁 next-key lock 先找到上一个值, 预设临键锁 (8,16]

where id=16因为16是存在的，那么退化为记录锁，仅锁住id=16这一行
where id=10因为10是不存在的，那么退化为间隙锁 (8,16)

where id>=8 and id<9范围查找，找到下一行16,预配(8,16],最终是记录锁 id=8 和间隙锁(8, 16)
```

### 2.非唯一索引等值查询和范围

> 普通索引等值查询，记录存在，next-key lock和间隙锁，不存在，next-key lock退化为间隙锁
> 普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁

```
where b=8 加锁next-key lock (4,8],间隙锁 (8,16)
此时 update where b=4是可以的 (记录锁)
insert (b=4) 会失败,因为insert会查看下一条记录是否加了间隙锁,如果加了会被阻塞,并生成插入意向锁
where b=10 加锁next-key lock(8,16],退化为间隙锁 (8,16)


where b>=8 and b<9 加锁 (4,8] 和 (8,16]
```

### (20 , +∞]

### 个人总结 - 唯一索引
```
加锁，首先看是否唯一索引，唯一索引且记录存在时候直接记录锁
不存在时候，锁住该值的上一个和下一个值之间的间隙,也就是间隙锁
范围查找也是记录锁和间隙锁
```
> 唯一索引就是记录锁或者间隙锁 

### 个人总结 - 非唯一索引
```
b=8 有等值，直接会锁住上一条记录和下一条记录[4,8,16]的整个间隙(4,16) 
b=10 无等值，直接间隙锁，(8,16)
范围的话, 直接间隙锁 (4,16)
```

### 唯一索引等值只锁一条记录锁,不然就是间隙锁,范围查找也是间隙锁，但是如果有等值就多一个记录锁

### 非唯一不管等值还是不等值还是范围，直接间隙锁，如果有等值8,那么是8的上一个值和下一个值的间隙锁


### insert会查看下一条记录是否加了间隙锁,如果加了会被阻塞,并生成插入意向锁
### insert会查看下一条记录是否加了间隙锁,如果加了会被阻塞,并生成插入意向锁
### insert会查看下一条记录是否加了间隙锁,如果加了会被阻塞,并生成插入意向锁

> 加锁一定是上一个值开始到这个值的范围，一定会被锁住，比如where b=8 , name(4，8] 一定被锁住,然后再看下一个值的区间是否会被锁住

### next-key lock 是前开后闭，而间隙锁是前开后开