# update没加索引会锁表吗

```
取决于update的where语句

加锁的位置准确的说，锁是加在索引上的而非行上
```

### 没有使用索引就会全表扫描 
```
对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了
对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了
对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了
```

### 但不是用了索引更新就一定会锁住全表的记录，因为有时候用了索引还是走了全表扫描

### 如何避免

> sql_safe_updates 安全更新模式 Where带上limit和索引列


### update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁
### update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁
### update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁
### update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁
### update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁
### update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁



> 对于 update  我们要的是记录锁，要的是尽可能缩小锁定的范围


### 在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了
### 在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了
### 在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了


### 全表扫描，在扫描过程中会对索引加锁 ?
### 全表扫描，在扫描过程中会对索引加锁 ?
### 全表扫描，在扫描过程中会对索引加锁 ?