# 索引常见面试题

### 什么是索引

```
一种数据结构，可以认为是数据的目录，帮助快速查找
```

### 索引底层使用了什么数据结构和算法

```
B+树
叶子节点双向链表
```

### 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构

```
查找快：高度3~4,磁盘IO次数少
范围查找：双向链表
```

### 有什么优化索引的方法

```
前缀索引优化
覆盖索引优化
主键索引最好是自增的
索引最好设置为 NOT NULL
防止索引失效
```

### 索引失效的情况

```
左或者左右模糊匹配
联合索引遵循最左匹配原则
OR 前的条件列是索引列，而在 OR 后的条件列不是索引列
表数据量很小(全表扫描更快的情况下，需要通过辅助索引查询到主键)
```


### 什么是MySQL的回表

```
回表就是 MySQL 要先到 “二级索引” 查询到主键值，然后再用主键索引定位到数据
从两个b+索引中去取数据

索引覆盖就是查这个索引能查到你所需要的所有数据，不需要去另外的数据结构去查，比如 select id from user where name='jack'; 
name为索引列获取ID可以不需要再去主键索引获取，也就是避免回表
```

### 什么时候不需要创建索引

```
索引列大量重复数据比如男\女,当某一个值占比很高时候查询优化器会选择忽略索引
数据表很小（辅助索引需要回表才能查询到数据，全表扫描更快）
频繁更新字段
```

### 索引分类

```
数据结构
物理存储：聚簇（主键）、二级（辅助）
字段特性
字段个数
```

### 从物理存储的角度来看，索引分为哪两种

```
索引分为聚簇索引（主键索引）、二级索引（辅助索引）
```

### left join优化技巧

```
小表驱动大表，被驱动表尽量带索引，因为驱动表需要逐行取出数据与被驱动表进行匹配，所以左边始终是逐行扫描的，但是被驱动表可以优化，如果给连接字段加上索引 ，可以极大提升查询速度
左表是逐行扫描的
```


### B+树的优势

```
高度：B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，查询一个数据磁盘IO在3~4次左右
范围查找：B+Tree叶子节点存储所有数据，并且双链表连接叶子节点，范围查找性能优异

从B+树的特性(排序)来看，order by的字段也很适合建立索引
```

### 主键索引和二级索引

```
主键索引：[完整的行记录] 都会存储在主键索引的叶子节点
二级索引：叶子节点 存放的其实是 [主键值] 而不是实际数据
```

### 为什么尽量避免索引列值为NULL

```
统计和值比较变得更复杂
更多的存储空间占用
```

### 事务四种隔离

```
Read uncommitted(读未提交)
Read committed(读提交)
Repeatable read(可重复读取)
Serializable(串行化)
```

### B+数索引查找 - 索引的key必须是有序的，这个也是联合索引遵循最左匹配原则的原因
```
分析一下 index(a,b)之中哪个字段用到了索引  explain的key_len字段值可以看出 “优化器具体使用了多少个字段的搜索条件  来形成扫描区间的边界条件”

对于联合索引，index(a,b) ，对于a字段是有序的在B+树，对于b字段是无序的，如果b>10这样查找是无法使用上索引的，但是如果b=10是可以用上索引的

m=j and n>2 // n也是能用到索引的，因为m=j的范围内，n是有序的
```

### 范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引
### 范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引

### 回表
```
辅助索引找到主键值后

回到主键索引查 数据行（行记录）
```

### 索引下推优化
```
MySQL5.6 引入的优化

index(a,b)

假设查询 where a=1 and b=2

找出 a=1 的辅助索引以后，先不去主键索引查数据

而是直接联合索引 index(a,b) 中，看看包含的字段（b）是否满足剩余查询条件
```

### 如何判断使用了索引下推优化
```
Explain 查看执行计划

Extra 字段值是 Using index condition
```


### 针对联合索引做的小优化 - 索引区分度
```
区分度大的字段排在前面

比如 age 和 name 那么 age的区分度更大

比如 UUID 区分度很大，性别的区分度会小很多
```

### 区分度很小的字段查找有时候会触发全表扫描
```
查询优化器发现

某个值出现在表的  数据行  中的百分比（惯用的百分比界线是"30%"）很高的时候

比如性别男女各占一半，查找 gender='男' 那么会触发圈全表扫描
```

### select * from order where status = 1 order by create_time asc 这个语句怎么优化（索引角度）

1. status增加索引
2. 建立联合索引 index(status,create_time) （会自然的对create_time进行排序）


### 建立索引缺点

1. 物理存储空间占用很大
2. 降低了增删改效率

### B+ 自带排序功能，为了查询更快可以建立索引，经常order by\group by的也可以建立索引


### 不需要创建索引的地方

1. 表数据太少
2. 经常更新的字段
3. 字段中存在大量重复数据（比如性别 - 只有男女）
4. 不会用于 where\group by\order by的字段

### 事务隔离级别可能带来的问题

```
脏读：A事务读到B事务没提交的数据
不可重复读：A事务内前后读取数据不一致
幻读：A事务前后读取的记录数量不一致，虽然读不到其他事务提交的数据但是里面会出现 duplicate entry for key 

问题的严重性

脏读 > 不可重复读 > 幻读
```


### 优化索引

1. 前缀（空间）
2. 覆盖（回表）
3. 主键索引自增 （非自增页分裂导致内存碎片）
4. 索引not null（count忽略null值行、行存储中多了null值列表） - 优化器在做索引选择的时候更加复杂


### 索引失效情况 

1. 左模糊和左右模糊匹配
2. 查询里面做计算、函数、类型转换
3. 联合索引最左匹配原则
4. or查找部分情况

### explain查看执行计划如果type is all的情况表示全表扫描 type is const 是王牌中的王牌

### extra 显示的 Using filesort文件排序 和 Using temporary临时表 和 Using index（所需数据只需在索引即可全部获得 - 覆盖索引，避免了回表操作，效率不错）


### MySQL全局锁/锁库

```
flush tables with read lock
unlock tables
```

### 表级锁 

1. 表锁 [共享锁\读锁] [独占锁\写锁]

```
lock tables t_student read;
lock tables t_stuent write;
unlock tables
```

2. 元数据锁 [MDL]

```
非显示使用，MySQL自动加

MDL读锁：表CURD时候
MDL写锁：表结构变更
```

3. 意向锁

```
意向共享锁
意向独占锁
```

4. AUTO-INC 锁

```
字段 AUTO_INCREMENT  属性，通过该锁实现
在插入数据时，会加一个表级别的 AUTO-INC 锁
```
还有一种轻量级锁也用于自增
```
当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁；
当 innodb_autoinc_lock_mode = 2，就采用轻量级锁；
当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。

innodb_autoinc_lock_mode = 2 是性能最高，但并发插入，自增长的值可能不连续，主从复制的场景中不安全
```


### 行锁

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁

1. Record Lock，记录锁
2. Gap Lock，间隙锁
3. Next-Key Lock：Record Lock + Gap Lock 的组合

> 普通的 select 语句是不会对记录加锁的，但是可以加

```
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```


### MVCC是啥
```
Multi-Version Concurrency Control 多版本并发控制
```

### 联合索引底层是啥
```
CREATE INDEX index_product_no_name ON product(product_no, name);
```

```
多个字段组成1个索引(每个b+叶子结点从根节点开始是以product_no作为排序依据,在product_no相同的情况下在对name做排序)

索引 index(a,b,c)

在底层B+树而言 a是有序的，而b是无序的，c也是无序的（b有序的前提是a是一致的情况）
索引需要用到必须 key是有序的

判断题:
index(a,b,c)，判断能否用到联合索引
where a=1 and b=2 and c=3
where b=2 and a=1 and c=3
where b=2 and c=3
where a=1
where a>1 and b=2 (a可以用上而b不可以用上索引)

```

### 联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like '林%'这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引


### MySQL 5.6引入索引下推优化，什么是索引下推
```
联合索引遍历过程之中，对联合索引包含的字段（先做判断，直接过滤不满足的记录）减少回表次数
```

### 如何判定MySQL执行语句效率

```
使用explain查看执行计划
possible_keys 可能用到的索引
key 实际用的索引
rows 扫描行数
type 扫描类型 
```

### MySQL执行计划扫描类型有哪些
```
效率从低到高(6种)
ALL
index
range
ref
eq_ref
const
```

### MySQL的事务实现原理\各个隔离级别下怎么做到的


### MySQL事务的特性有哪些(ACID)
```
原子(Atomicity)  所有操作要么全部成功要么全部失败
一致(Consistency) 数据库处理前后结果应与其所抽象的客观世界中真实状况保持一致
隔离(Isolation) 多个事务之间隔离互不干扰
持久(Durability) 事务提交以后数据永久改变
```

### MySQL的事务特性隔离性是如何实现的



### 什么是索引下推

https://blog.csdn.net/ww823883473/article/details/123490487

```
减少回表次数
联合索引

假定联合索引 index(a,b,c)，当索引a,c时候，由于b的缺失，索引只能查到a下面的所有索引，回到主键索引查处数据再判断c的匹配
那么有了索引下推，他会判定c是否存在联合索引，如果存在则自动补全b之类，从而减少回表的次数
```

