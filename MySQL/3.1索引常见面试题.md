# 索引常见面试题

### 什么是索引

```
一种数据结构，可以认为是数据的目录，帮助快速查找
```

### 索引底层使用了什么数据结构和算法

```
B+树
叶子节点双向链表
```

### 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构

```
查找快：高度3~4,磁盘IO次数少
范围查找：双向链表
```

### 有什么优化索引的方法

```
前缀索引优化
覆盖索引优化
主键索引最好是自增的
索引最好设置为 NOT NULL
防止索引失效
```

### 索引失效的情况

```
左或者左右模糊匹配
联合索引遵循最左匹配原则
OR 前的条件列是索引列，而在 OR 后的条件列不是索引列
表数据量很小(全表扫描更快的情况下，需要通过辅助索引查询到主键)
```


### 什么是MySQL的回表

```
回表就是 MySQL 要先到 “二级索引” 查询到主键值，然后再用主键索引定位到数据
从两个b+索引中去取数据

索引覆盖就是查这个索引能查到你所需要的所有数据，不需要去另外的数据结构去查，比如 select id from user where name='jack'; 
name为索引列获取ID可以不需要再去主键索引获取，也就是避免回表
```

### 什么时候不需要创建索引

```
索引列大量重复数据比如男\女,当某一个值占比很高时候查询优化器会选择忽略索引
数据表很小（辅助索引需要回表才能查询到数据，全表扫描更快）
频繁更新字段
```

### 索引分类

```
数据结构
物理存储：聚簇（主键）、二级（辅助）
字段特性
字段个数
```

### 从物理存储的角度来看，索引分为哪两种

```
索引分为聚簇索引（主键索引）、二级索引（辅助索引）
```

### left join优化技巧

```
小表驱动大表，被驱动表尽量带索引，因为驱动表需要逐行取出数据与被驱动表进行匹配，所以左边始终是逐行扫描的，但是被驱动表可以优化，如果给连接字段加上索引 ，可以极大提升查询速度
左表是逐行扫描的
```


### B+树的优势

```
高度：B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，查询一个数据磁盘IO在3~4次左右
范围查找：B+Tree叶子节点存储所有数据，并且双链表连接叶子节点，范围查找性能优异

从B+树的特性(排序)来看，order by的字段也很适合建立索引
```

### 主键索引和二级索引

```
主键索引：[完整的行记录] 都会存储在主键索引的叶子节点
二级索引：叶子节点 存放的其实是 [主键值] 而不是实际数据
```

### 为什么尽量避免索引列值为NULL

```
统计和值比较变得更复杂
更多的存储空间占用
```

### 事务四种隔离

```
Read uncommitted(读未提交)
Read committed(读提交)
Repeatable read(可重复读取)
Serializable(串行化)
```

### 事务隔离级别可能带来的问题

```
脏读：A事务读到B事务没提交的数据
不可重复读：A事务内前后读取数据不一致
幻读：A事务前后读取的记录数量不一致，虽然读不到其他事务提交的数据但是里面会出现 duplicate entry for key 

问题的严重性

脏读 > 不可重复读 > 幻读
```


### MySQL全局锁/锁库

```
flush tables with read lock
unlock tables
```

### 表级锁 

1. 表锁 [共享锁\读锁] [独占锁\写锁]

```
lock tables t_student read;
lock tables t_stuent write;
unlock tables
```

2. 元数据锁 [MDL]

```
非显示使用，MySQL自动加

MDL读锁：表CURD时候
MDL写锁：表结构变更
```

3. 意向锁

```
意向共享锁
意向独占锁
```

4. AUTO-INC 锁

```
字段 AUTO_INCREMENT  属性，通过该锁实现
在插入数据时，会加一个表级别的 AUTO-INC 锁
```
还有一种轻量级锁也用于自增
```
当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁；
当 innodb_autoinc_lock_mode = 2，就采用轻量级锁；
当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。

innodb_autoinc_lock_mode = 2 是性能最高，但并发插入，自增长的值可能不连续，主从复制的场景中不安全
```


### 行锁

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁

1. Record Lock，记录锁
2. Gap Lock，间隙锁
3. Next-Key Lock：Record Lock + Gap Lock 的组合

> 普通的 select 语句是不会对记录加锁的，但是可以加

```
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```


### MVCC是啥
```
Multi-Version Concurrency Control 多版本并发控制
```

### 联合索引底层是啥
```
CREATE INDEX index_product_no_name ON product(product_no, name);
```

```
多个字段组成1个索引(每个b+叶子结点从根节点开始是以product_no作为排序依据,在product_no相同的情况下在对name做排序)

索引 index(a,b,c)

在底层B+树而言 a是有序的，而b是无序的，c也是无序的（b有序的前提是a是一致的情况）
索引需要用到必须 key是有序的

判断题:
index(a,b,c)，判断能否用到联合索引
where a=1 and b=2 and c=3
where b=2 and a=1 and c=3
where b=2 and c=3
where a=1
where a>1 and b=2 (a可以用上而b不可以用上索引)

```

### 联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like '林%'这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引


### MySQL 5.6引入索引下推优化，什么是索引下推
```
联合索引遍历过程之中，对联合索引包含的字段（先做判断，直接过滤不满足的记录）减少回表次数
```

### 如何判定MySQL执行语句效率

```
使用explain查看执行计划
possible_keys 可能用到的索引
key 实际用的索引
rows 扫描行数
type 扫描类型 
```

### MySQL执行计划扫描类型有哪些
```
效率从低到高(6种)
ALL
index
range
ref
eq_ref
const
```

### MySQL的事务实现原理\各个隔离级别下怎么做到的


### MySQL事务的特性有哪些(ACID)
```
原子(Atomicity)  所有操作要么全部成功要么全部失败
一致(Consistency) 数据库处理前后结果应与其所抽象的客观世界中真实状况保持一致
隔离(Isolation) 多个事务之间隔离互不干扰
持久(Durability) 事务提交以后数据永久改变
```

### MySQL的事务特性隔离性是如何实现的

