# 事务隔离级别实现原理

(MySQL事务隔离级别实现原理)[https://www.cnblogs.com/gaokeji/p/16375381.html]

### 锁

> ... IN SHARE MODE 
> ... FOR UPDATE

### 特性
```
ACID特性
```

### 解决的问题

### 脏读
```
事务A读到事务B未提交的数据
```

### 不可重复读
```
事务A内重复读取行记录row_1 再次读取后列内容发生了改变

读取了其他事务更改的数据，针对update操作
```

### 幻读  (简书博客幻读)[https://www.jianshu.com/p/c921f995d58b] (腾讯云博客)[https://cloud.tencent.com/developer/article/1450773]
```
事务A第一次查询得到row_1 第二次查询得到了 row_1 & row_2
事务前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行
其他事务insert之后统计数据的总量

读取了其他事务新增的数据，针对insert和delete操作
```

### 隔离级别

1. 读未提交（read uncommitted）(RU)
2. 读提交（read committed）(RC)
3. 可重复读（repeatable read）(RR) 默认隔离级别
4. 序列化读（serializable）(S)

<hr/>

### 锁机制

1. 序列化 [老子直接给你锁表] [当前读]
```
事务内读取，表级共享锁
事务内更新，表级排他锁
事务结束后释放
```

2. 未提交读 [行锁] [当前读]
```
读取直接不加锁
更新加共享锁 ｜ 更新了数据还没提交事务其他事务一样能读取到
事务结束后释放
```

3. 读已提交 [行锁] [快照读]
```
读取加共享锁，读完就释放 ｜ 允许其他事务并发读
更新加互斥锁，事务结束后释放 ｜ 更新了我没提交其他事务就读不了
```

4. 可重复读 RR [快照读]
```
读取加行级共享锁 ｜ 允许其他事务并发读
更新加行级排他锁 ｜ 更新了我没提交其他事务就读不了
事务结束才释放
```

### 当前读

> 读取记录最新版本

### 快照读

> 读取的快照版本(历史版本)


### 在RR的级别，可重复读的情况，读取row1的status为1，此时其他事务将status更改为2并提交成功，执行update set status=3 where status=1 那么执行成功吗


### 为什么说间隙锁解决了幻读的问题
```
间隙锁给一个范围加共享锁，从而阻止其他事务对这个范围获取互斥锁insert或者delete数据
```

### 什么是间隙锁

https://cloud.tencent.com/developer/article/1806998

> 间隙锁锁住的是一个范围