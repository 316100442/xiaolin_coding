# 幻读是如何被解决的


### 不可重复读 - 强调的是内容不一样了，但是两次都可以找到的

### 幻读 - 强调的行记录之前不存在，后面看到了

### 幻读就是快照读无法读取到（因为MVCC）而当前读（update\insert\delete这些操作）却可以发现某些其他事务提交的数据(聚簇索引里面的数据)
### 幻读就是快照读无法读取到（因为MVCC）而当前读（update\insert\delete这些操作）却可以发现某些其他事务提交的数据(聚簇索引里面的数据)
### 幻读就是快照读无法读取到（因为MVCC）而当前读（update\insert\delete这些操作）却可以发现某些其他事务提交的数据(聚簇索引里面的数据)
### 幻读就是快照读无法读取到（因为MVCC）而当前读（update\insert\delete这些操作）却可以发现某些其他事务提交的数据(聚簇索引里面的数据)
### 幻读就是快照读无法读取到（因为MVCC）而当前读（update\insert\delete这些操作）却可以发现某些其他事务提交的数据(聚簇索引里面的数据)
### 幻读就是快照读无法读取到（因为MVCC）而当前读（update\insert\delete这些操作）却可以发现某些其他事务提交的数据(聚簇索引里面的数据)
### 幻读就是快照读无法读取到（因为MVCC）而当前读（update\insert\delete这些操作）却可以发现某些其他事务提交的数据(聚簇索引里面的数据)

### 查询带上了 for update

> 事务A 无法保证表数据（聚簇索引）不能被其他事务更改，但是可以把这些锁起来不让其他事务更改某一个范围，也算是防止幻读


### MySQL Innodb 中的 MVCC 并不能完全避免幻读现象 ---- 通过update这种当前读更改记录的trx_id，虽然select快照读看不到但是update之后就可以看到


### 避免幻读的终极大招就是一开始执行当前读 select ... for update 直接锁上
### 避免幻读的终极大招就是一开始执行当前读 select ... for update 直接锁上
### 避免幻读的终极大招就是一开始执行当前读 select ... for update 直接锁上
### 避免幻读的终极大招就是一开始执行当前读 select ... for update 直接锁上
### 避免幻读的终极大招就是一开始执行当前读 select ... for update 直接锁上


### 幻读的定义

```
一个事务内多次查询符合查询条件的 [记录数量],如果出现前后查询得到的记录数量不一致，就意味着发生了幻读现象
```

> 可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的，但是update这种操作就是当前读了

### 快照读和当前读

```
MySQL 里除了普通查询是快照读
其他都是当前读，比如update、insert、delete
这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。
```

### select ... for update 是当前读

### 讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下

### Innodb 引擎为了解决 [可重复读] 隔离级别使用 [当前读] 而造成的幻读问题，就引出了 next-key 锁

```
A事务查询范围 id in 1~100
使用next-key锁锁住这个范围
期间如果有其他事务在这个锁住的范围插入数据就会被阻塞
从而避免幻读

所以，update 语句的 where 条件没有用到索引列

那么就会全表扫描，在一行行扫描的过程中，不仅给行数据加上了行锁
还给行两边的空隙也加上了间隙锁，相当于锁住整个表
然后直到事务结束才会释放锁

在线上千万不要执行没有带索引的 update 语句
在线上千万不要执行没有带索引的 update 语句
在线上千万不要执行没有带索引的 update 语句
```


### update 导致整个表被锁住
### update 导致整个表被锁住
### update 导致整个表被锁住
### update 导致整个表被锁住
### update 导致整个表被锁住
### update 导致整个表被锁住

### 无索引 - 全表扫描 - 加上了行锁、加上了间隙锁